---
order: 1
title: Camera Component
type: Graphics
group: Camera
label: Graphics/Camera
---

The camera is an abstract concept of [3D projection](https://en.wikipedia.org/wiki/3D_projection) that a graphics engine acts like a camera or eyes in the real world. The camera of Galacean Engine implements automatic frustum culling, and only renders objects inside the frustum.

CullingMask case:

<playground src="renderer-cull.ts"></playground>

## Basic usage

```typescript
// Creat entity.
const entity = root.createChild("cameraEntity");
// Create Camera.
const camera = entity.addComponent(Camera);
camera.nearClipPlane = 0.1;
camera.farClipPlane = 100;

// Set perspective projection properties.
camera.fieldOfView = 60;

// Get camera through the entity.
entity.engine.sceneManager.activeScene._activeCameras[0];
```

## Projection type

By setting [isOrthographic](${api}core/Camera#isOrthographic) to decide whether to use perspective projection or orthogonal projection.

### Perspective projection

The perspective projection is in line with our near-large and far-small model. You can look at the schematic diagram of the perspective model:

![image.png](https://gw.alipayobjects.com/mdn/rms_d27172/afts/img/A*isMHSpe21ZMAAAAAAAAAAAAAARQnAQ)

According to the above figure, it can be seen that the near clipping plane([nearClipPlane](${api}core/Camera#nearClipPlane)), far clipping plane([farClipPlane](${api}core/Camera#farClipPlane)) And angle of view ([fieldOfView](${api}core/Camera#fieldOfView)) will form a frustum ([_View Frustum_](https://en.wikipedia.org/wiki/Viewing_frustum)). Objects inside the frustum will be projected into the camera, that is, rendered on the canvas, while objects outside the frustum will be cropped.

### Orthogonal projection

Orthogonal projection means that the objects seen near and far in the viewing area are of equal size. The viewable area generated by the orthogonal projection model is called the box-shaped viewable area, and the box-shaped viewable area model is as follows:

![image.png](https://gw.alipayobjects.com/mdn/rms_d27172/afts/img/A*KEuGSqX-vXsAAAAAAAAAAAAAARQnAQ)

As shown in the figure above, there are top, bottom, left and right. Galacean has made some simplifications to the orthogonal properties, which is more in line with the developer’s usage habits. Only [orthographicSize](${api}core/Camera#orthographicSize)(orthogonal Half the size of the camera in mode). The following is the relationship between each attribute and [orthographicSize](${api}core/Camera#orthographicSize).

- `top = orthographicSize`
- `bottom = -orthographicSize`
- `right = orthographicSize * aspectRatio`
- `left = -orthographicSize * aspectRatio`

### How to choose

After comparing perspective projection and orthogonal projection, it can be intuitively found that they have the following main differences:

- **Viewable area model**
- **Does it have the effect of being near big and far small**

Therefore, when used in actual projects, the type of projection is generally determined by the visual effect you want to obtain. For example, when you need to show 2D effects, you choose orthographic projection, and when you need to show 3D effects, you choose perspective projection.

### isOrthographic

<playground src="ortho-switch.ts"></playground>

## Attributes

| Type | Attributes | Meaning |
| :-- | :-- | :-- |
| Universal | [isOrthographic](${api}core/Camera#isOrthographic) | Whether it is an orthogonal projection, the default is `false` |
|  | [aspectRatio](${api}core/Camera#aspectRatio) | The canvas aspect ratio is usually calculated automatically based on the canvas size, or it can be changed manually (not recommended) |
|  | [cullingMask](${api}core/Camera#cullingMask) | The crop mask is used to selectively render the rendering components in the scene. |
|  | [priority](${api}core/Camera#priority) | The rendering priority is used to determine the order in which the content contained in the camera is rendered in the case of multiple cameras. |
|  | [renderTarget](${api}core/Camera#renderTarget) | The rendering target determines which target the content will be rendered to. |
|  | [viewport](${api}core/Camera#viewport) | The viewport, which determines the scope of the content that is finally rendered to the target device. |
| | [pixelViewport](${api}core/Camera#pixelViewport) | The viewport of the camera in pixel coordinates on the screen. In pixel screen coordinates, the upper-left corner is (0, 0), and the lower-right corner is (1.0, 1.0). |
|  | [nearClipPlane](${api}core/Camera#nearClipPlane) | Near clipping plane |
|  | [farClipPlane](${api}core/Camera#farClipPlane) | Far clipping plane |
| Perspective projection | [fieldOfView](${api}core/Camera#fieldOfView) | Field of view |
| Orthogonal projection | [orthographicSize](${api}core/Camera#orthographicSize) | Half the size of the camera in orthographic mode |
|  | [depthTextureMode]((${api}core/Camera#depthTextureMode)) | Depth texture mode, defalut is `DepthTextureMode.None` |

For details, please read [API documentation](${api}core/Camera)。

### cullingMask

The camera can selectively render the nodes in the scene, just set the mask corresponding to the camera and the node. (Note: The child node obtained by the node's createChild method will inherit the Layer of the parent node)

<playground src="renderer-cull.ts"></playground>

### `renderTarget` && `priority` && `clearFlags`

In the case of multiple cameras, we can combine the camera's `renderTarget`,  `priority` and `clearFlags`, and we can complete many advanced implementations, such as using the rendering results of multiple cameras to achieve a picture-in-picture effect.

<playground src="multi-camera.ts"></playground>

### Camera orientation

Since in Galacean, the world coordinate system is a right-handed system, the positive direction of any node faces the -Z axis. Similarly, the positive direction of the camera (viewing direction) is also the -Z axis direction, and so on. In Unity and other world coordinates In a left-handed engine, the positive direction of the camera is the +Z axis.

### Depth texture

The camera can enable the depth texture through the [depthTextureMode]((${api}core/Camera#depthTextureMode)) attribute. After the depth texture is enabled, the depth texture can be accessed in the Shader through the `camera_DepthTexture` attribute. Depth textures can be used to achieve soft particles and water edge transitions, as well as some simple post-processing effects.
Note: Depth textures only render non-transparent objects.

<playground src="camera-depth-texture.ts"></playground>

## method

| Properties | Explanation |
| :------------------------------------------------ ----------- | :------------------------------------- -- |
| [resetProjectionMatrix](${api}core/Camera#resetProjectionMatrix) | Reset custom projection matrix, back to automatic mode. |
| [resetAspectRatio](${api}core/Camera#resetAspectRatio) | Reset custom rendering aspect ratio and return to automatic mode. |
| [worldToViewportPoint](${api}core/Camera#worldToViewportPoint) | Convert a point from world space to viewport space. |
| [viewportToWorldPoint](${api}core/Camera#viewportToWorldPoint) | Convert a point from viewport space to world space. |
| [viewportPointToRay](${api}core/Camera#viewportPointToRay) | Generates a world space ray through a point in viewport space. |
| [screenToViewportPoint](${api}core/Camera#screenToViewportPoint) | Convert a point from screen space to viewport space. |
| [viewportToScreenPoint](${api}core/Camera#viewportToScreenPoint) | Convert a point from viewport space to screen space. |
| [worldToScreenPoint](${api}core/Camera#worldToScreenPoint) | Convert a point from world space to screen space. |
| [screenToWorldPoint](${api}core/Camera#screenToWorldPoint) | Convert a point from screen space to world space. |
| [screenPointToRay](${api}core/Camera#screenPointToRay) | Generates a world space ray through a point in screen space. |
| [render](${api}core/Camera#render) | Manual rendering. |
| [setReplacementShader](${api}core/Camera#setReplacementShader) | Set the global rendering replacement shader. |
| [resetReplacementShader](${api}core/Camera#resetReplacementShader) | Clear the global rendering replacement shader. |◊

## Q&A

### How to render when there are multiple cameras in the scene?

First review the attributes `priority`, `renderTarget` and `viewport` mentioned earlier. When there are multiple cameras in a scene at the same time, we will determine the attributes of the camera queue rendering according to the `priority` each time the rendering is called. According to `viewport`, determine which range of `renderTarget` needs to be rendered finally.

<playground src="multi-camera.ts"></playground>

### How to use the camera and controls together？

For details, please read [Controls](${docs}controls)。
